# 14. 정수론

### 14.2 소수











* 소수 : *prime number* : 양의 약수가 1과 자기 자신 두개 뿐인 자연수
* 합성수 : *composite number* :세 개 이상의 양의 약수를 갖는 자연수를 합성수



#### 소수 판별

* 2 부터 n-1까지의 모든 수를 순회하면서 이중 n의 약수 있는지 확인
* 합성수 n = p/times q로 표현 될 때 한 수는 항상 $$\sqrt{n}$$  

$\sqrt{n}$

**코드 14.1 0() 시간에 동작하는 소수 판별 알고리즘**

``` python
import math

def isPrime(n):
    if n == 1 :
      return False
    if n == 2 :
      return True
    if n % 2 == 0 :
      return False
    
    sqrtn = math.sqrt(n)

    for div in range(3,int(sqrtn) +1,2):

      if n % div == 0 :
        return False
        
    return True

print(isPrime(7))

```



``` python

```



#### 에라토스테네스의 체



지워지지 않은 수들을 순회하며 이 수의 배수를 지운다.

1. 

1. 지워지지 않는 첫번째 수 2 --> 2의 배수들을 전부 지운다.
2. 다음으로 지워지지 않은 수 3 --> 3의 배수들을 전부 지운다.
3. 같은 방법으로 5, 7... 의 배수들을 지운다.

=> 남는 수 : 소수

* 지워지지 않는 수를 찾을 때 \sqrt{n} 까지만 찾는다. (소수 판정 알고리즘 기반)



``` python
def isPrime(n)
```



###### 예제 : 에라토스테네스의 체를 이용한 빠른 소인수분해





* 각 숫자의 가장 작은 소인수를 같이 기록한다.

  

### 14.3 문제 : 비밀번호 486 (문제 ID : PASS486, 난이도 : 중)





### 14.4 유클리드 알고리즘





두 수의 최대 공약수를 구하는 방법

p,q (p>q)의 공약수의 집합은 p-q와 q의 공약수 집합과 같다는 점을 이용

* gcd(p,q) = gcd(p-q, q)

1.

```python
def gcd(a,b):
    a = a if a>b else b
    b = a + b - r1
    
    if b == 0:
        return a
    return gcd(a-b, b)
```

-> 시간이 오래 걸린다.



2.

```python
def gcd(a,b):
    if b == 0 :
        return a
    return gcd(b, a % b)
```

1번과 다르게 a<b일 때 처리를 따로 하지 않았다. 

a<b인 입력이 들어올 경우 a%b = b이므로, 다음 재귀 함수 호출은 gcd(b,a) 가 된다.



###### 

### 14.6 문제 : 마법의 약 (문제 ID : POTION, 난이도 : 중)



### 14.8 모듈라 연산





두 수의 더한 뒤 나머지를 취하는 것은 미리 두수의 나머지를 구한 뒤 더하고, 다시 나머지를 취하는 것과 같다.



* (a + b) % M = ((a % M) + (b % M)) % M
* (a - b) % M = ((a % M) - (b % M)) % M
* (a * b) % M = ((a % M) * (b % M)) % M
* *나눗셈은 위와 같은 공식이 성립하지 않는다*



### 14.9 더 읽을거리





#### 확장 유클리드 알고리즘



```python
def eea(a, b):          #returns r, s, t such that s*a+t*b=r
    r1 = a if a>b else b
    r2 = a+b-r1
    r = 0
    s1, s2, s = 1, 0, 0
    t1, t2, t = 0, 1, 0
    q = 0
    while(r2>0):
        q = r1 // r2
        r = r1 - q*r2
        r1, r2 = r2, r
        s = s1 - q*s2
        s1, s2 = s2, s
        t = t1 - q*t2
        t1, t2 = t2, t
    return r1, s1, t1
```







#### 중국인 나머지 정리 (Chinese Remainder Theroem)

#### 루카스의 정리 (Lucas' Theorem)





다른 말은


$$
\sqrt{2}
$$






